#ifndef DYNARR_H
#define DYNARR_H

// TODO: let user set malloc/realloc/free
// TODO: messsages with assert macro?
// TODO: handle max size
// TODO: ensure that dynarr_{count,data} are inlined

#include <assert.h> // assert
#include <stddef.h> // size_t
#include <string.h> // memcpy

#if defined(DYNARR_REALLOC) != defined(DYNARR_FREE)
#error "You must either set both DYNARR_REALLOC and DYNARR_FREE but not both"
#endif

#ifndef DYNARR_REALLOC
#include <stdlib.h> // realloc, free
#define DYNARR_REALLOC realloc
#define DYNARR_FREE free
#endif

#ifndef DYNARR_DEFAULT_CAP
#define DYNARR_DEFAULT_CAP 8
#endif

#ifndef DYNARR_RESIZE_FACTOR
#define DYNARR_RESIZE_FACTOR 2
#endif

#ifdef DYNARR_SHORT_NAMES
#define arrpushr   dynarr_push_rval
#define arrsetr    dynarr_set_rval
#define arrinsertr dynarr_insert_rval

#define dynarr_init_count arrinitcnt
#define dynarr_init       arrinit
#define dynarr_resize     arrresize
#define dynarr_free       arrfree
#define dynarr_push       arrpush
#define dynarr_pop_ptr    arrpopp
#define dynarr_pop        arrpop
#define dynarr_set        arrset
#define dynarr_get_ptr    arrgetp
#define dynarr_get        arrget
#define dynarr_insert     arrinsert
#define dynarr_count      arrcount
#define dynarr_data       arrdata
#endif

// _rval variations of all functions that add new data to the array

#define dynarr_push_rval(arr, val) \
	do { \
		__auto_type tmp = val; \
		assert(sizeof(tmp) == arr->_elt_size); \
		dynarr_push(arr, &tmp); \
	} while (0)

#define dynarr_set_rval(arr, idx, val) \
	do { \
		__auto_type tmp = val; \
		assert(sizeof(tmp) == arr->_elt_size); \
		dynarr_set(arr, idx, &tmp); \
	} while (0)

#define dynarr_insert_rval(arr, idx, val) \
	do { \
		__auto_type tmp = val; \
		assert(sizeof(tmp) == arr->_elt_size); \
		dynarr_insert(arr, idx, &tmp); \
	} while (0)

typedef struct {
	void  *_data;
	size_t _cap;      // number of elements allocated
	size_t _count;    // number of elements in use
	size_t _elt_size; // size of each element
} dynarr_t;

dynarr_t *dynarr_init_count(size_t element_size, size_t initial_cap);
dynarr_t *dynarr_init(size_t element_size);
void dynarr_resize(dynarr_t *arr, size_t new_cap);
void dynarr_free(dynarr_t *arr);

void  dynarr_push(dynarr_t *arr, void *src);
void *dynarr_pop_ptr(dynarr_t *arr);
void  dynarr_pop(dynarr_t *arr, void *dest);
void  dynarr_set(dynarr_t *arr, size_t idx, void *src);
void *dynarr_get_ptr(dynarr_t *arr, size_t idx);
void  dynarr_get(dynarr_t *arr, size_t idx, void *dest);
void  dynarr_insert(dynarr_t *arr, size_t idx, void *src);

size_t dynarr_count(dynarr_t *arr);
void *dynarr_data(dynarr_t *arr);

#endif

// vim: ft=c noet tw=80
